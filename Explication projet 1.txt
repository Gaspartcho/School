Compte rendu projet séquence 1, explication du code:

Introduction :
Ce programme python est le résultat du projet de fin de séquence 1 du manuel. Il comporte les deux propositions (Conversion d’entiers positifs et norme IEEE-754), ainsi que tous les exercices qui les composent.

Description du programme :
Mon programme est divisée en trois grandes parties : deux classes, prop_1 et prop_2  comportant chacune les réponses pour chaque proposition, ainsi qu’une partie « interface », qui comporte le code pour les interactions avec l’utilisateur. Chaque classes est composée d’un certain nombre de fonctions, chacune représentant l’un des exercices à réaliser.

La première classe, prop_1 comporte les réponses aux exercices de la proposition 1 de l’énoncé. Elle comporte une fonction principale, decimale_base(n, base), qui permet de convertir n’importe-quel nombre entier naturel décimal en la base choisie, de 1 a 36, ce qui correspond au nombre de caractères présent dans la variable « alphabet » au dessus de la fonction (il est techniquement possible de coder en une base supérieure, mais il faudrait rallonger l’alphabet avec d’autres caractères, mais je ne suis pas sur des quels et dans quel ordre, donc pour des raisons de compatibilité, j’ai décidé de m’arrêter aux chiffres et aux lettres minuscules de l’alphabet latin). Comme le demande l’énoncé, elle prend deux valeurs « n » et « base », avec n et base des entiers naturels, avec « n » le nombre a convertir et « base » la base demandée. Les deux autres fonctions decimale_binaire(n) et decimale_hexadecimale(n) utilisent toutes les deux la fonction decimale_base() avec les arguments « n » le nombre a convertir et « base » respectivement 2 et 16 selon la fonction.

La fonction decimale_base() commence par vérifier si il est capable d’accepter la base demandée par l’utilisateur. Pour cela, il vérifie si la base demandée si est supérieure ou non au nombre de caractères présents dans la variable « alphabet ». Si c’est le cas, le programme renvoie une erreur et s’arrête. Ensuite, il vérifie si le signe de n est négatif, et s’arrête en renvoyant une erreur également si c’est le cas. Si non, il importe juste l’intervalle de la variable alphabet nécessaire à la conversion du nombre. Ensuite, il renvoie l’équivalent de zéro dans l’alphabet demandé si la valeur de « n » est 0. Il convertis ensuite le nombre dans la base demandée à l’aide de la méthode vue en classe, en stockant les restes des divisions euclidiennes dans une liste, puis la renverse et la convertis sous une forme de chaîne de caractères et la renvoie. 

La deuxième classe prop_2 comporte les réponses aux exercices 2 et 3 de la proposition 2 de l’énoncé, la question 1 étant déjà répondue dans la partie « interface ». Cette classe comporte donc deux fonctions : norme_IEEE(n) et somme(n, m). La première fonction prend un seul argument : n, un nombre réel. Comme ce programme fonctionne avec la méthode de simple précision (32 bits) ce nombre devra être situé soit entre 3,40 282 346 × 1038 et 1,4 × 10−45, soit entre leurs équivalents négatifs. Dans le cas contraire, le programme risque de ne pas fonctionner correctement, et renverra une valeur fausse, dû à un « integer overflow ». 

La fonction commence directement a écrire le premier chiffre du résultat en fonction du signe de n, puis il le met à sa valeur absolue. Ensuite, il sépare le nombre en deux partie, la partie entière et la partie décimale. Il traduit ensuite le la partie entière du nombre en base décimale, à l’aide de la fonction prop_1.decimale_binaire(). Comme la mantisse est codée sur 23 bits dans ce programme, il vérifie que ce nombre en binaire peut rentrer dans ces 23 bits. Si non, il réduit ce nombre aux 24 plus grands chiffres, et assigne l’exposant au nombre de bits de ce nombre moins 1. Ensuite, il convertis en binaire la partie décimale à l’aide de la méthode vue en classe, tout en faisant attention à que la longueur de ce nombre binaire plus celle de la représentation binaire de la partie entière du nombre ne dépasse pas les 24 caractères. Il arrondis ensuite la dernière valeur de ce nombre décimal au supérieur.

L’étape suivante est de déterminer l’exposant du nombre utilisé. Pour cela, le programme vérifie d’abord si l’exposant n’a pas déjà été définis plus tôt. Si non, il l’assigne en faisant en sorte que l’on puisse écrire le nombre binaire en écriture scientifique avec cet exposant comme exposant. Ensuite, comme le demande la norme, on ajoute 127 à ce nombre et on le convertis en binaire. Dans le doute où ce nombre binaire contiendrais moins de 8 chiffres, le programme ajoute des 0 devant la représentation binaire de l’exposant jusqu’à que ce nombre soit codé sur 8 bits. Enfin, il combine la partie entière et décimale du nombre en binaire, il enlève le premier chiffre du nombre, car con sait qu’il sera toujours a 1 puis il le combine avec les représentations du signe et de l’exposant de sorte que le nombre s’affiche de la sorte : « signe exposant mantisse (nombre) ». Il renvoie finalement le résultat.

La deuxième fonction de cette classe, somme(), prend deux argument : n et m. Cette fonction est beaucoup plus simple, comme elle additionne simplement des deux nombres les arrondis aux plus petit chiffre significatif (donc avec le même nombre de chiffres après la virgule que celui avec le plus d’entre elles), puis renvoie l’écriture en norme IEEE-754 de ce nombre obtenu.

La troisième partie du programme est la partie dédiée à l’interface avec l’utilisateur. Il lui permet de choisir l’exercice en lui posant deux questions : quelle proposition veut-il voir, et quel exercice de la proposition veut-il faire. Il comporte aussi toutes les entrées que l’utilisateur vas devoir entrer  Pour les exercices de la proposition 1, il précise dans quelle base le nombre viens d’être codé. Il comporte également une série de fonctions « print() » qui recensent un petit paragraphe expliquant comment la norme IEEE-754 fonctionne, répondant ainsi à la question 1 de la proposition 2.

Conclusion :
Je trouve qu’il n’y a pas beaucoup de choses à améliorer dans mon code, à part peut-être plus de base possibles en quelles coder pour la proposition 1, ou encore une manière plus optimisée pour coder un nombre décimal en base 2 ou 16. De plus, je pourrais améliorer l’interface de l’utilisateur (rajouter des informations pour les instructions, mettre certains textes en couleurs pour que ce soit plus agréable à lire …). Néanmoins, je pense que ces petites améliorations ne sont pas nécessaires, donc je vais laisser mon programme tel qu’il est. Je n’ai pas rencontré de difficultés particulières pendant la programmation, même si j’ai mis plus de temps à comprendre le fonctionnement de la norme IEEE-754.
